import {
  invariant
} from "./chunk-NDDE4XKZ.js";
import {
  arrayify,
  keccak256
} from "./chunk-HDQMERUC.js";
import {
  require_react
} from "./chunk-3S5REVRK.js";
import {
  ConnectorEvent
} from "./chunk-LRXMOTBU.js";
import {
  tiny_warning_esm_default
} from "./chunk-7EE7PWU2.js";
import {
  __toESM
} from "./chunk-QOVRSCHT.js";

// node_modules/.pnpm/@web3-react+core@6.1.9_react@17.0.2/node_modules/@web3-react/core/dist/core.esm.js
var import_react = __toESM(require_react());
function _extends() {
  _extends = Object.assign || function(target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i];
      for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }
    return target;
  };
  return _extends.apply(this, arguments);
}
function _inheritsLoose(subClass, superClass) {
  subClass.prototype = Object.create(superClass.prototype);
  subClass.prototype.constructor = subClass;
  _setPrototypeOf(subClass, superClass);
}
function _getPrototypeOf(o) {
  _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf2(o2) {
    return o2.__proto__ || Object.getPrototypeOf(o2);
  };
  return _getPrototypeOf(o);
}
function _setPrototypeOf(o, p) {
  _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf2(o2, p2) {
    o2.__proto__ = p2;
    return o2;
  };
  return _setPrototypeOf(o, p);
}
function _isNativeReflectConstruct() {
  if (typeof Reflect === "undefined" || !Reflect.construct)
    return false;
  if (Reflect.construct.sham)
    return false;
  if (typeof Proxy === "function")
    return true;
  try {
    Date.prototype.toString.call(Reflect.construct(Date, [], function() {
    }));
    return true;
  } catch (e) {
    return false;
  }
}
function _construct(Parent, args, Class) {
  if (_isNativeReflectConstruct()) {
    _construct = Reflect.construct;
  } else {
    _construct = function _construct2(Parent2, args2, Class2) {
      var a = [null];
      a.push.apply(a, args2);
      var Constructor = Function.bind.apply(Parent2, a);
      var instance = new Constructor();
      if (Class2)
        _setPrototypeOf(instance, Class2.prototype);
      return instance;
    };
  }
  return _construct.apply(null, arguments);
}
function _isNativeFunction(fn) {
  return Function.toString.call(fn).indexOf("[native code]") !== -1;
}
function _wrapNativeSuper(Class) {
  var _cache = typeof Map === "function" ? /* @__PURE__ */ new Map() : void 0;
  _wrapNativeSuper = function _wrapNativeSuper2(Class2) {
    if (Class2 === null || !_isNativeFunction(Class2))
      return Class2;
    if (typeof Class2 !== "function") {
      throw new TypeError("Super expression must either be null or a function");
    }
    if (typeof _cache !== "undefined") {
      if (_cache.has(Class2))
        return _cache.get(Class2);
      _cache.set(Class2, Wrapper);
    }
    function Wrapper() {
      return _construct(Class2, arguments, _getPrototypeOf(this).constructor);
    }
    Wrapper.prototype = Object.create(Class2.prototype, {
      constructor: {
        value: Wrapper,
        enumerable: false,
        writable: true,
        configurable: true
      }
    });
    return _setPrototypeOf(Wrapper, Class2);
  };
  return _wrapNativeSuper(Class);
}
var _iteratorSymbol = typeof Symbol !== "undefined" ? Symbol.iterator || (Symbol.iterator = Symbol("Symbol.iterator")) : "@@iterator";
var _asyncIteratorSymbol = typeof Symbol !== "undefined" ? Symbol.asyncIterator || (Symbol.asyncIterator = Symbol("Symbol.asyncIterator")) : "@@asyncIterator";
function _catch(body, recover) {
  try {
    var result = body();
  } catch (e) {
    return recover(e);
  }
  if (result && result.then) {
    return result.then(void 0, recover);
  }
  return result;
}
function normalizeChainId(chainId) {
  if (typeof chainId === "string") {
    chainId = chainId.replace(/^Ox/, "0x");
    var parsedChainId = Number.parseInt(chainId, chainId.trim().substring(0, 2) === "0x" ? 16 : 10);
    !!Number.isNaN(parsedChainId) ? true ? invariant(false, "chainId " + chainId + " is not an integer") : invariant(false) : void 0;
    return parsedChainId;
  } else {
    !Number.isInteger(chainId) ? true ? invariant(false, "chainId " + chainId + " is not an integer") : invariant(false) : void 0;
    return chainId;
  }
}
function normalizeAccount(_address) {
  !(typeof _address === "string" && _address.match(/^(0x)?[0-9a-fA-F]{40}$/)) ? true ? invariant(false, "Invalid address " + _address) : invariant(false) : void 0;
  var address = _address.substring(0, 2) === "0x" ? _address : "0x" + _address;
  var chars = address.toLowerCase().substring(2).split("");
  var charsArray = new Uint8Array(40);
  for (var i = 0; i < 40; i++) {
    charsArray[i] = chars[i].charCodeAt(0);
  }
  var hashed = arrayify(keccak256(charsArray));
  for (var _i = 0; _i < 40; _i += 2) {
    if (hashed[_i >> 1] >> 4 >= 8) {
      chars[_i] = chars[_i].toUpperCase();
    }
    if ((hashed[_i >> 1] & 15) >= 8) {
      chars[_i + 1] = chars[_i + 1].toUpperCase();
    }
  }
  var addressChecksum = "0x" + chars.join("");
  !!(address.match(/([A-F].*[a-f])|([a-f].*[A-F])/) && address !== addressChecksum) ? true ? invariant(false, "Bad address checksum " + address + " " + addressChecksum) : invariant(false) : void 0;
  return addressChecksum;
}
var augmentConnectorUpdate = function augmentConnectorUpdate2(connector, update) {
  try {
    var _temp3 = function _temp32(provider) {
      return Promise.resolve(Promise.all([update.chainId === void 0 ? connector.getChainId() : update.chainId, update.account === void 0 ? connector.getAccount() : update.account])).then(function(_ref2) {
        var _chainId = _ref2[0], _account = _ref2[1];
        var chainId = normalizeChainId(_chainId);
        if (!!connector.supportedChainIds && !connector.supportedChainIds.includes(chainId)) {
          throw new UnsupportedChainIdError(chainId, connector.supportedChainIds);
        }
        var account = _account === null ? _account : normalizeAccount(_account);
        return {
          provider,
          chainId,
          account
        };
      });
    };
    var _temp4 = update.provider === void 0;
    return Promise.resolve(_temp4 ? Promise.resolve(connector.getProvider()).then(_temp3) : _temp3(update.provider));
  } catch (e) {
    return Promise.reject(e);
  }
};
var StaleConnectorError = function(_Error) {
  _inheritsLoose(StaleConnectorError2, _Error);
  function StaleConnectorError2() {
    var _this;
    _this = _Error.call(this) || this;
    _this.name = _this.constructor.name;
    return _this;
  }
  return StaleConnectorError2;
}(_wrapNativeSuper(Error));
var UnsupportedChainIdError = function(_Error2) {
  _inheritsLoose(UnsupportedChainIdError2, _Error2);
  function UnsupportedChainIdError2(unsupportedChainId, supportedChainIds) {
    var _this2;
    _this2 = _Error2.call(this) || this;
    _this2.name = _this2.constructor.name;
    _this2.message = "Unsupported chain id: " + unsupportedChainId + ". Supported chain ids are: " + supportedChainIds + ".";
    return _this2;
  }
  return UnsupportedChainIdError2;
}(_wrapNativeSuper(Error));
var ActionType;
(function(ActionType2) {
  ActionType2[ActionType2["ACTIVATE_CONNECTOR"] = 0] = "ACTIVATE_CONNECTOR";
  ActionType2[ActionType2["UPDATE"] = 1] = "UPDATE";
  ActionType2[ActionType2["UPDATE_FROM_ERROR"] = 2] = "UPDATE_FROM_ERROR";
  ActionType2[ActionType2["ERROR"] = 3] = "ERROR";
  ActionType2[ActionType2["ERROR_FROM_ACTIVATION"] = 4] = "ERROR_FROM_ACTIVATION";
  ActionType2[ActionType2["DEACTIVATE_CONNECTOR"] = 5] = "DEACTIVATE_CONNECTOR";
})(ActionType || (ActionType = {}));
function reducer(state, _ref) {
  var type = _ref.type, payload = _ref.payload;
  switch (type) {
    case ActionType.ACTIVATE_CONNECTOR: {
      var connector = payload.connector, provider = payload.provider, chainId = payload.chainId, account = payload.account, onError = payload.onError;
      return {
        connector,
        provider,
        chainId,
        account,
        onError
      };
    }
    case ActionType.UPDATE: {
      var _provider = payload.provider, _chainId2 = payload.chainId, _account2 = payload.account;
      return _extends({}, state, _provider === void 0 ? {} : {
        provider: _provider
      }, _chainId2 === void 0 ? {} : {
        chainId: _chainId2
      }, _account2 === void 0 ? {} : {
        account: _account2
      });
    }
    case ActionType.UPDATE_FROM_ERROR: {
      var _provider2 = payload.provider, _chainId3 = payload.chainId, _account3 = payload.account;
      return _extends({}, state, _provider2 === void 0 ? {} : {
        provider: _provider2
      }, _chainId3 === void 0 ? {} : {
        chainId: _chainId3
      }, _account3 === void 0 ? {} : {
        account: _account3
      }, {
        error: void 0
      });
    }
    case ActionType.ERROR: {
      var error = payload.error;
      var _connector = state.connector, _onError = state.onError;
      return {
        connector: _connector,
        error,
        onError: _onError
      };
    }
    case ActionType.ERROR_FROM_ACTIVATION: {
      var _connector2 = payload.connector, _error = payload.error;
      return {
        connector: _connector2,
        error: _error
      };
    }
    case ActionType.DEACTIVATE_CONNECTOR: {
      return {};
    }
  }
}
function useWeb3ReactManager() {
  var _useReducer = (0, import_react.useReducer)(reducer, {}), state = _useReducer[0], dispatch = _useReducer[1];
  var connector = state.connector, provider = state.provider, chainId = state.chainId, account = state.account, onError = state.onError, error = state.error;
  var updateBusterRef = (0, import_react.useRef)(-1);
  updateBusterRef.current += 1;
  var activate = (0, import_react.useCallback)(function(connector2, onError2, throwErrors) {
    if (throwErrors === void 0) {
      throwErrors = false;
    }
    try {
      var updateBusterInitial = updateBusterRef.current;
      var activated = false;
      return Promise.resolve(_catch(function() {
        return Promise.resolve(connector2.activate().then(function(update) {
          activated = true;
          return update;
        })).then(function(update) {
          return Promise.resolve(augmentConnectorUpdate(connector2, update)).then(function(augmentedUpdate) {
            if (updateBusterRef.current > updateBusterInitial) {
              throw new StaleConnectorError();
            }
            dispatch({
              type: ActionType.ACTIVATE_CONNECTOR,
              payload: _extends({
                connector: connector2
              }, augmentedUpdate, {
                onError: onError2
              })
            });
          });
        });
      }, function(error2) {
        if (error2 instanceof StaleConnectorError) {
          activated && connector2.deactivate();
          true ? tiny_warning_esm_default(false, "Suppressed stale connector activation " + connector2) : void 0;
        } else if (throwErrors) {
          activated && connector2.deactivate();
          throw error2;
        } else if (onError2) {
          activated && connector2.deactivate();
          onError2(error2);
        } else {
          dispatch({
            type: ActionType.ERROR_FROM_ACTIVATION,
            payload: {
              connector: connector2,
              error: error2
            }
          });
        }
      }));
    } catch (e) {
      return Promise.reject(e);
    }
  }, []);
  var setError = (0, import_react.useCallback)(function(error2) {
    dispatch({
      type: ActionType.ERROR,
      payload: {
        error: error2
      }
    });
  }, []);
  var deactivate = (0, import_react.useCallback)(function() {
    dispatch({
      type: ActionType.DEACTIVATE_CONNECTOR
    });
  }, []);
  var handleUpdate = (0, import_react.useCallback)(function(update) {
    try {
      if (!connector) {
        throw Error("This should never happen, it's just so Typescript stops complaining");
      }
      var updateBusterInitial = updateBusterRef.current;
      return Promise.resolve(function() {
        if (!error) {
          var _chainId4 = update.chainId === void 0 ? void 0 : normalizeChainId(update.chainId);
          if (_chainId4 !== void 0 && !!connector.supportedChainIds && !connector.supportedChainIds.includes(_chainId4)) {
            var _error2 = new UnsupportedChainIdError(_chainId4, connector.supportedChainIds);
            onError ? onError(_error2) : dispatch({
              type: ActionType.ERROR,
              payload: {
                error: _error2
              }
            });
          } else {
            var _account4 = typeof update.account === "string" ? normalizeAccount(update.account) : update.account;
            dispatch({
              type: ActionType.UPDATE,
              payload: {
                provider: update.provider,
                chainId: _chainId4,
                account: _account4
              }
            });
          }
        } else {
          return _catch(function() {
            return Promise.resolve(augmentConnectorUpdate(connector, update)).then(function(augmentedUpdate) {
              if (updateBusterRef.current > updateBusterInitial) {
                throw new StaleConnectorError();
              }
              dispatch({
                type: ActionType.UPDATE_FROM_ERROR,
                payload: augmentedUpdate
              });
            });
          }, function(error2) {
            if (error2 instanceof StaleConnectorError) {
              true ? tiny_warning_esm_default(false, "Suppressed stale connector update from error state " + connector + " " + update) : void 0;
            } else {
              onError ? onError(error2) : dispatch({
                type: ActionType.ERROR,
                payload: {
                  error: error2
                }
              });
            }
          });
        }
      }());
    } catch (e) {
      return Promise.reject(e);
    }
  }, [connector, error, onError]);
  var handleError = (0, import_react.useCallback)(function(error2) {
    onError ? onError(error2) : dispatch({
      type: ActionType.ERROR,
      payload: {
        error: error2
      }
    });
  }, [onError]);
  var handleDeactivate = (0, import_react.useCallback)(function() {
    dispatch({
      type: ActionType.DEACTIVATE_CONNECTOR
    });
  }, []);
  (0, import_react.useEffect)(function() {
    return function() {
      if (connector) {
        connector.deactivate();
      }
    };
  }, [connector]);
  (0, import_react.useEffect)(function() {
    if (connector) {
      connector.on(ConnectorEvent.Update, handleUpdate).on(ConnectorEvent.Error, handleError).on(ConnectorEvent.Deactivate, handleDeactivate);
    }
    return function() {
      if (connector) {
        connector.off(ConnectorEvent.Update, handleUpdate).off(ConnectorEvent.Error, handleError).off(ConnectorEvent.Deactivate, handleDeactivate);
      }
    };
  }, [connector, handleUpdate, handleError, handleDeactivate]);
  return {
    connector,
    provider,
    chainId,
    account,
    activate,
    setError,
    deactivate,
    error
  };
}
var PRIMARY_KEY = "primary";
var CONTEXTS = {};
function createWeb3ReactRoot(key) {
  !!CONTEXTS[key] ? true ? invariant(false, "A root already exists for provided key " + key) : invariant(false) : void 0;
  CONTEXTS[key] = (0, import_react.createContext)({
    activate: function() {
      try {
        true ? true ? invariant(false, "No <Web3ReactProvider ... /> found.") : invariant(false) : void 0;
        return Promise.resolve();
      } catch (e) {
        return Promise.reject(e);
      }
    },
    setError: function setError() {
      true ? invariant(false, "No <Web3ReactProvider ... /> found.") : invariant(false);
    },
    deactivate: function deactivate() {
      true ? invariant(false, "No <Web3ReactProvider ... /> found.") : invariant(false);
    },
    active: false
  });
  CONTEXTS[key].displayName = "Web3ReactContext - " + key;
  var Provider = CONTEXTS[key].Provider;
  return function Web3ReactProvider2(_ref) {
    var getLibrary = _ref.getLibrary, children = _ref.children;
    var _useWeb3ReactManager = useWeb3ReactManager(), connector = _useWeb3ReactManager.connector, provider = _useWeb3ReactManager.provider, chainId = _useWeb3ReactManager.chainId, account = _useWeb3ReactManager.account, activate = _useWeb3ReactManager.activate, setError = _useWeb3ReactManager.setError, deactivate = _useWeb3ReactManager.deactivate, error = _useWeb3ReactManager.error;
    var active = connector !== void 0 && chainId !== void 0 && account !== void 0 && !!!error;
    var library = (0, import_react.useMemo)(function() {
      return active && chainId !== void 0 && Number.isInteger(chainId) && !!connector ? getLibrary(provider, connector) : void 0;
    }, [active, getLibrary, provider, connector, chainId]);
    var web3ReactContext = {
      connector,
      library,
      chainId,
      account,
      activate,
      setError,
      deactivate,
      active,
      error
    };
    return import_react.default.createElement(Provider, {
      value: web3ReactContext
    }, children);
  };
}
var Web3ReactProvider = createWeb3ReactRoot(PRIMARY_KEY);
function getWeb3ReactContext(key) {
  if (key === void 0) {
    key = PRIMARY_KEY;
  }
  !Object.keys(CONTEXTS).includes(key) ? true ? invariant(false, "Invalid key " + key) : invariant(false) : void 0;
  return CONTEXTS[key];
}
function useWeb3React(key) {
  return (0, import_react.useContext)(getWeb3ReactContext(key));
}
export {
  PRIMARY_KEY,
  UnsupportedChainIdError,
  Web3ReactProvider,
  createWeb3ReactRoot,
  getWeb3ReactContext,
  useWeb3React
};
//# sourceMappingURL=@web3-react_core.js.map
